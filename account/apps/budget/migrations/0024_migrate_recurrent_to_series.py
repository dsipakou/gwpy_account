# Generated by Django 4.2.20 on 2026-01-27 07:46

from collections import defaultdict
from datetime import date, timedelta

from dateutil.relativedelta import relativedelta
from django.db import migrations


def migrate_recurrent_to_series(apps, _schema_editor):
    """Migrate budgets with recurrent field to use BudgetSeries"""
    Budget = apps.get_model("budget", "Budget")
    BudgetSeries = apps.get_model("budget", "BudgetSeries")

    # Frequency mapping
    FREQUENCY_MAP = {
        "weekly": "WEEKLY",
        "monthly": "MONTHLY",
    }

    # Get all budgets with recurrent field set (excluding occasional and None)
    # Order by title, user, and budget_date to process chronologically per series
    budgets = (
        Budget.objects.filter(recurrent__in=["weekly", "monthly"])
        .select_related("user", "workspace", "category", "currency", "series")
        .order_by("user", "title", "budget_date")
    )

    # Group budgets by (user_id, title, frequency) to identify potential series
    budget_groups = defaultdict(list)
    for budget in budgets:
        if not budget.budget_date:
            continue
        frequency = FREQUENCY_MAP.get(budget.recurrent)
        if not frequency:
            continue

        key = (budget.user_id, budget.title, frequency)
        budget_groups[key].append(budget)

    migrated_count = 0
    series_created_count = 0
    series_reused_count = 0
    series_deleted_count = 0
    series_ended_count = 0

    # Process each group of budgets that belong to the same series
    for (_user_id, _title, frequency), group_budgets in budget_groups.items():
        if not group_budgets:
            continue

        # Sort by date to ensure chronological processing
        group_budgets.sort(key=lambda b: b.budget_date)

        # Start with the first budget
        first_budget = group_budgets[0]

        # Check if a suitable series already exists
        suitable_series = BudgetSeries.objects.filter(
            user=first_budget.user,
            title=first_budget.title,
            frequency=frequency,
        ).first()

        old_series = first_budget.series

        if suitable_series:
            # Suitable series exists - we'll use it
            series_reused_count += 1
        else:
            # Create a new series from the first budget
            suitable_series = BudgetSeries.objects.create(
                user=first_budget.user,
                workspace=first_budget.workspace,
                title=first_budget.title,
                category=first_budget.category,
                currency=first_budget.currency,
                amount=first_budget.amount,
                start_date=first_budget.budget_date,
                frequency=frequency,
                interval=1,
                count=None,
                until=None,
            )
            series_created_count += 1

        # Link the first budget to the series
        first_budget.series = suitable_series
        first_budget.save(update_fields=["series"])
        migrated_count += 1

        # Process subsequent budgets in this group
        last_budget_date = first_budget.budget_date
        current_series = suitable_series
        budgets_after_gap = []  # Track budgets after a gap before creating new series

        for i in range(1, len(group_budgets)):
            current_budget = group_budgets[i]
            previous_budget = group_budgets[i - 1]

            # Check if this budget continues the sequence based on frequency
            # Must be same user and follow the date pattern
            is_gap = False

            # First check: must be the same user
            if current_budget.user_id != previous_budget.user_id:
                is_gap = True
            elif frequency == "MONTHLY":
                # For monthly budgets: check if it's exactly one month later (same day)
                # relativedelta handles edge cases automatically (e.g., Jan 31 -> Feb 28)
                expected_next_date = last_budget_date + relativedelta(months=1)
                if current_budget.budget_date == expected_next_date:
                    # Exact match - continuation
                    is_gap = False
                else:
                    # Not exact next month - gap detected
                    is_gap = True
            elif frequency == "WEEKLY":
                # For weekly budgets: check if it's exactly 7 days later (same weekday)
                expected_next_date = last_budget_date + timedelta(weeks=1)
                if current_budget.budget_date == expected_next_date:
                    # Exact match - continuation
                    is_gap = False
                else:
                    # Not exact next week - gap detected
                    is_gap = True

            # Check if there's a gap (current budget is not the expected next occurrence)
            if is_gap:
                # If we were accumulating budgets after a previous gap, those budgets stay unlinked
                budgets_after_gap.clear()

                # Gap detected - end the current series
                if current_series:
                    current_series.until = last_budget_date
                    current_series.save(update_fields=["until"])
                    series_ended_count += 1
                    current_series = None  # No active series now

                # Don't create a new series yet, just track this budget
                budgets_after_gap.append(current_budget)
                last_budget_date = current_budget.budget_date
                migrated_count += 1

            else:
                # This budget continues the sequence
                if current_series is None:
                    # We're after a gap and now continuing - create new series
                    first_after_gap = (
                        budgets_after_gap[0] if budgets_after_gap else current_budget
                    )

                    current_series = BudgetSeries.objects.create(
                        user=first_after_gap.user,
                        workspace=first_after_gap.workspace,
                        title=first_after_gap.title,
                        category=first_after_gap.category,
                        currency=first_after_gap.currency,
                        amount=first_after_gap.amount,
                        start_date=first_after_gap.budget_date,
                        frequency=frequency,
                        interval=1,
                        count=None,
                        until=None,
                    )
                    series_created_count += 1

                    # Link all budgets that were waiting after the gap
                    for budget_to_link in budgets_after_gap:
                        budget_to_link.series = current_series
                        budget_to_link.save(update_fields=["series"])

                    budgets_after_gap.clear()

                # Link current budget to the current series
                current_budget.series = current_series
                current_budget.save(update_fields=["series"])
                last_budget_date = current_budget.budget_date
                migrated_count += 1

        # After processing all budgets, check if the current series should be ended
        # If the last budget is more than 2 periods in the past, assume the series has ended
        if current_series and current_series.until is None:
            today = date.today()
            if frequency == "MONTHLY":
                # If last budget is more than 2 months in the past, end the series
                threshold_date = today - relativedelta(months=2)
            elif frequency == "WEEKLY":
                # If last budget is more than 2 weeks in the past, end the series
                threshold_date = today - timedelta(weeks=2)
            else:
                threshold_date = None

            if threshold_date and last_budget_date < threshold_date:
                current_series.until = last_budget_date
                current_series.save(update_fields=["until"])
                series_ended_count += 1

        # Clean up old series if needed
        if old_series and old_series != suitable_series:
            other_budgets_using_old_series = Budget.objects.filter(
                series=old_series
            ).exists()
            if not other_budgets_using_old_series:
                old_series.delete()
                series_deleted_count += 1

    print("Migration complete:")
    print(f"  - Budgets migrated: {migrated_count}")
    print(f"  - New series created: {series_created_count}")
    print(f"  - Existing series reused: {series_reused_count}")
    print(f"  - Series ended (until date set): {series_ended_count}")
    print(f"  - Orphaned series deleted: {series_deleted_count}")


def reverse_migration(apps, _schema_editor):
    """Reverse the migration by clearing series from migrated budgets"""
    Budget = apps.get_model("budget", "Budget")

    # Clear series for budgets that have recurrent field set
    budgets = Budget.objects.filter(
        recurrent__in=["weekly", "monthly"], series__isnull=False
    )

    count = budgets.count()
    budgets.update(series=None)

    print(f"Reverse migration complete: {count} budgets unlinked from series")


class Migration(migrations.Migration):
    dependencies = [
        ("budget", "0023_budgetseries_budgetseriesexception_and_more"),
    ]

    operations = [
        migrations.RunPython(migrate_recurrent_to_series, reverse_migration),
    ]
